# Сериализация двусвязного списка с произвольными ссылками

Приложение на C++17, которое:
1. Читает описание двусвязного списка из текстового файла `inlet.in`
2. Строит список в памяти (`ListNode`)
3. Сериализует список в бинарный файл `outlet.out`

---

## Структура проекта

```
.
├── CMakeLists.txt
├── main.cpp
├── ListNode.h                  # Структура узла
├── types.h                     # using Data = vector<pair<string, int>>
├── parser/
│   ├── parser.h
│   └── parser.cpp              # Парсер .in файла
├── ListCreator/
│   ├── ListCreator.h
│   └── ListCreator.cpp         # Построение связного списка из Data
├── validator/
│   └── validator.h             # Валидация входных данных
└── serializer/
    └── serializer.h            # Бинарная сериализация
```

---

## Как собрать и запустить

### Требования

- CMake ≥ 3.16
- Компилятор с поддержкой C++17 (GCC, Clang)

### Сборка CMake

```bash
mkdir build
cmake -S . -B build
cmake --build build -j$(nproc)
```
### Сборка без CMake
```bash
g++ -std=c++17 main.cpp ListCreator/ListCreator.cpp parser/parser.cpp -o EM_Test
```
### Запуск

Положите файл `inlet.in` рядом с исполняемым файлом (или в рабочую директорию) и запустите:

```bash
./EM_Test
```

После выполнения в той же директории появится файл `outlet.out`.

---

## Формат входного файла (`inlet.in`)

Каждая строка описывает один узел:

```
<data>;<rand_index>
```

- `<data>` — произвольная строка (UTF-8, пробелы, спецсимволы допустимы), до 1000 символов
- `<rand_index>` — целое число: индекс узла (0-based), на который указывает `rand`, либо `-1` если `rand == nullptr`
- Разделитель — **последний** символ `;` в строке (данные сами могут содержать `;`)

**Пример:**

```
apple;2
banana;-1
carrot;1
```

Узел 0: `apple`, rand → узел 2 (`carrot`)  
Узел 1: `banana`, rand → `nullptr`  
Узел 2: `carrot`, rand → узел 1 (`banana`)

---

## Как работает программа

### 1. Parser

Открывает файл построчно. Для каждой строки:
- Находит **последний** символ `;` как разделитель (защита от `;` в данных)
- Валидирует длину `data` (≤ 1000 символов) и корректность `rand_index` (≥ -1)
- Проверяет лимит узлов (≤ 10⁶)
- Результат — вектор пар `{string, int}`

### 2. ListCreator

Принимает разобранные данные и строит список в два прохода:
- **Первый проход** — создаёт все узлы, связывает `prev`/`next`, заполняет `data`
- **Второй проход** — проставляет `rand` по индексу (через вспомогательный вектор указателей)

При исключении во втором проходе список корректно освобождается.

### 3. Serializer

Записывает в бинарный файл:
- `int32_t count` — количество узлов
- Для каждого узла по порядку:
  - `int32_t dataLen` — длина строки `data`
  - `char[dataLen]` — байты строки
  - `int32_t randIndex` — индекс узла `rand` или `-1`

Указатели `prev`/`next` не сериализуются явно — они восстанавливаются по порядку записи.

---

## Ограничения

| Параметр | Значение |
|----------|----------|
| Максимум узлов | 10⁶ |
| Максимальная длина `data` | 1000 символов |
| Кодировка | UTF-8 |

---

## Архитектурные замечания

### Текущая реализация

`Parser` — конкретный класс без интерфейса.

### Рекомендация для production

В реальной разработке предложил бы ввести абстрактный интерфейс `IParser`:

```cpp
class IParser {
public:
    virtual void parseFile() = 0;
    virtual const Data& getData() const = 0;
    virtual ~IParser() = default;
};
```

Тогда текущий `Parser` становится `INParser` (парсер `.in`-файлов), а при смене формата входных данных (JSON, CSV, бинарный файл) достаточно реализовать новый класс — без изменения `ListCreator`, `main` и остальной логики. Это соответствует **принципу открытости/закрытости (OCP)** из SOLID: код открыт для расширения, закрыт для модификации.

Аналогично можно абстрагировать и `Serializer`, если потребуется поддержка нескольких форматов вывода.

---
